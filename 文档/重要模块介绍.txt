代码中重要模块简介
Character:角色
用于表示所有的可见的,有一定逻辑的角色,一般人型模型表示的都应该是一个角色,比如战斗中的角色,主界面的角色,高模展示的角色,次级场景中的角色.
角色中一般包含一个数据类,和对该角色的访问方法.数据类中只有成员变量,不能有函数
CommandSystem:命令系统
  特点:
  1.封装逻辑
  2.连接逻辑与界面,以及项目中任何模块
  3.延迟执行
  4.线程安全,在子线程中可以使用延迟命令将逻辑放到主线程执行
  5.日志打印
  基于以上特点,命令系统一般是用在表示一件逻辑意义上的事件,命令中可访问任意项目代码,所以当一个事件关联多个模块时,应该将相关代码封装到一个命令中
  比如数据改变时,即有数据存储的改变,也有界面相应的改变,那就需要将该逻辑封装到命令中,在合适的地方调用命令即可.调用方只需要关心触发了什么事件,
  而不需要关心事件具体内容.
  命名规范:文件夹名字格式为Cmd+接收者类名,命令格式为Cmd+接收者类名+命令名,接收者必须为一个存在的类名,一般只使用父类名即可.
  禁止将命令发送给不对应的接收者.可发送给Global
  使用延迟命令需要考虑到中断情况,也就是在还没有到命令执行的事件时不满足命令执行的条件.这时候应该将命令中断,也就是调用CommandSystem.interruptCommand(),将命令从等待列表中移除.
Common:公共代码
  一般存放枚举,全局基类,当前项目使用的工具函数等.
Component:组件
  类似于unity的组件思想.使用组合的方式代替继承,实现不同对象的不同行为.
  组件一般是用于实现部分可以独立更新的逻辑.需要更新,并且与拥有者本身没有太大的耦合性的逻辑,可以写到组件中添加到拥有者上.
DataBase:仅用于存放表格数据,json表格,SQLite表格,或自定义表格数据
DynamicAttachScript:运行时动态添加的MonoBehaviour脚本,一般用于运行时在检视面板查看调试信息.
Game:程序入口,也是程序结构的根节点,最顶层的管理类
GameScene:游戏逻辑场景
  游戏总体划分为多个逻辑场景,分别代表游戏不同的阶段,一般由所使用的资源和逻辑共同决定逻辑场景划分.
  一个逻辑场景包含若干个流程,流程以树形结构存储.逻辑场景至少包含一个起始流程和退出流程.
  流程表示逻辑场景内部的状态划分,流程的切换一般都会有界面的相应切换.
  进入流程时的操作一般与退出流程时的操作对应,比如进入流程时打开了一个界面,那退出流程时就应该将此界面关闭.进入流程时禁用了某项操作,退出流程时就应该重新启用此操作.
  流程之间不允许互相访问,流程之间应该是相对隔离的,仅允许在进入或者退出流程时判断上一个流程或者下一个流程的类型来执行不同的逻辑.
  流程切换时仅会停止对旧流程的更新,启用新流程的更新,不会销毁任何流程.
  逻辑场景切换时会销毁旧逻辑场景以及此场景的所有流程,加载并初始化新逻辑场景.
  一个逻辑场景一般会使用若干个资源场景,并且根据流程切换资源场景显示
  命名规范:逻辑场景名:场景名+Scene,流程名:场景名+Scene+父流程名(如果有父流程)+流程名
UI:界面脚本,只要是使用了Canvas的都可以归类到界面.无论是2D的UI还是场景中的3DUI.
Net:网络通信.存放网络管理器,网络消息包
SceneSystem:资源场景逻辑脚本.每一个资源场景都会对应一个逻辑脚本,允许多个相似的资源场景使用一个逻辑脚本.