自动生成代码:
需要手动在ILRLaunch.cs中添加需要跨域继承的类,点击菜单生成适配器,生成完以后再添加注册适配器
需要手动在ILRLaunch.cs中添加热更工程要使用的值类型,进行值类型绑定

主工程中:
不能使用new T(),除非能够确定T是主工程的类型
不能使用typeof(T),除非能够确定T是主工程的类型
尽量不使用泛型,使用手动传入Type代替
不要直接使用Type.GetType获取类型,因为这样无法区分热更类型和非热更类型,应该使用Typeof(obj)
需要在热更中调用的函数需要为public权限,否则无法导出
被热更工程间接继承的类,如果在热更工程引用了这个被间接继承的类,则也需要将这个类添加跨域继承适配器.否则将会出现类型转换失败.
如果想要调用热更工程中的函数,则需要将函数签名先在ILRFrameUtility或者ILRGameUtility中定义,然后在函数中使用指定的方式调用热更的函数.其他地方要调用时则只需要调用已定义的函数即可.避免直接通过字符串来调用热更的函数.

热更工程中:
可以使用typeof(T),获取热更工程或者主工程的类型
不能使用多线程,开启多线程
不能在继承了主工程的类以后再继承接口,会引起奇怪的崩溃和报错
不能使用主工程中带ref的委托
如果想要让主工程能够访问热更工程的一些函数,则只能在ILRExport中,将要开放给主工程的函数再使用一个静态函数封装一层.作为一个公共的静态接口.
如果在热更工程中出现跨域继承的类调用相同基类的其他实例的同名函数,比如在一个Command的execute中调用另外一个Command的execute,会出现调用出错,这是ILR本身的错误导致,就需要修改相关类的继承适配器代码,将函数的静态变量移到Adapter中,改为非静态变量
将类转换为非直接继承的基类时,比如转换为父类的父类,将可能转换失败.可以先使用is判断是否属于某个直接父类,然后再显示转换为直接父类.而非直接转换到父类的父类.